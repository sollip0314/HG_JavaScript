<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    // 객체(Object) : 키(key)와 값(value)의 쌍으로 이루어진 데이터 구조
    /*
    요소에 접근할 때
    - 배열 : 인덱스(index)
    - 객체 : 키(key)
    */

    const product = {
      제품명 : '맛있는 망고',
      유형 : '당절임',
      성분 : '망고, 설탕, 나트륨',
      원산지 : '필리핀'
    }
    
    document.write(product['제품명'])
    document.write('<br>')
    document.write(product['성분'])
    document.write('<br><br>')

    // 위의 표현을 아래와 같이 할수도 있다.
    document.write(product.제품명)
    document.write('<br>')
    document.write(product.성분)
    document.write('<br><br>')

    // 객체의 요소 추가
    document.write('부피를 출력합니다.<br>')
    document.write(product.부피 = '500ml')
    document.write('<br><br>')

    // 객체의 요소 전체 출력
    document.write('객체 전체를 출력합니다.<br>')
    for (const key in product) {
      document.write(`${key}: ${product[key]}<br>`);
    }
    
    // 객체의 요소 삭제
    document.write('부피 요소를 제거합니다.<br><br>')
    delete product.부피;

    // 객체의 요소 전체 출력
    document.write('객체 전체를 출력합니다.<br>')
    for (const key in product) {
      document.write(`${key}: ${product[key]}<br>`);
    }

    // 객체생성① : 비구조화 할당을 통한 객체 생성
    const makePerson = ({lastName, firstName, age}) =>{
      return {
        name : `${lastName}${firstName}`,
        age   // 'age: age'와 동일한 의미
      };
    };
    const person1 = makePerson({lastName : 'Park', firstName:'Jiho', age : 40})
    console.log(person1)

    // 객체생성② : 생성자를 통한 객체 생성
    class Person {
      constructor({lastName, firstName, age}) {
        this.name = `${lastName}${firstName}`;
        this.age = age;
      }
    }

    const person2 = new Person({lastName: 'Park', firstName: 'Jiho', age: 40});
    console.log(person2)


    // 객체 분해 ( 구조분해할당 )
    const obj = {name : '박지호', objective : '행복하자'}
    const {name, objective} = obj;
    console.log(name, objective); // 박지호 행복하자

    // 객체 병합 ① 
    const person = {
      name : 'Jiho Park',
      age  : 40,
      country : 'South Korea',
      city    : 'Seoul'
    };    
    const address = {
      city    : 'New York',
      country : 'USA'
    };
    const merge = { ...person, ...address};
    console.log(merge);

    // 객체 병합 (Trend)
    // func 함수는 flag가 true이면 실행
    // flag && func();
    const makeCompany = (showAddress) => {
      return {
        name : 'TESLA',
        industry : 'AI & Electric Vehicles',
        ...(showAddress && {
          address : {
            city : 'Texas',
            country : 'USA'
          }
        })
        // showAddress가 true일 때만 address 속성이 추가됩니다.
      };
    }
    console.log(makeCompany(true));  // address 속성이 포함됩니다.
    console.log(makeCompany(false)); // address 속성이 포함되지 않습니다.

    // 객체 병합 (Old)
    const makeOldCompany = (showAddress) => {
      const company = {
        name: 'ExonMobil',
        industry: 'Energy',
      };
      
      if (showAddress) {
        company.address = {
          city: 'Irving, Texas',
          country: 'USA'
        };
      }
      
      return company;
    };
    console.log(makeOldCompany(true));  // address 속성이 포함됩니다.
    console.log(makeOldCompany(false)); // address 속성이 포함되지 않습니다.
  </script>
</head>
<body>
  
</body>
</html>