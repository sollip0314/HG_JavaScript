<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JS Array Mastery</title>
  <script>
    /* =====================================================
       1. 배열의 정의 및 선언 (Array Declaration)
    ===================================================== */
    // 배열에 들어갈 수 있는 데이터 타입 : 숫자, 문자열, 불린, 함수, 객체, 배열
    const array = [123, 'String', true, function(){}, {}, [12, 34]]

    // ① 생성자 방식: 공간(length)을 먼저 확보한 뒤 배치
    // [ Array(Size) -> Spread(...) -> map() -> New Array ]
    // new Array(5): [empty × 6] (실체 없음, map이 건너뜀)
    // [...new Array(5)]: [undefined, undefined, ..., undefined] (실체가 생김, map이 방문함)
    // map((value, index) => ...): 인덱스를 이용해 값 생성
    const arr1 = [...new Array(5)].map((_, i) => i + 1); // [1, 2, 3, 4, 5]
    
    // ② 단순 초기화 방식 Fill 메서드: 모든 공간을 동일한 값으로 초기화
    const arr4 = new Array(5).fill(0); // [0, 0, 0, 0, 0, 0]
    
    // ③ 2차원 행렬
    const rows = 3;
    const cols = 4;
    const matrix = Array.from(Array(row1), () => new Array(col2).fill(0));

    // ④ 생성자 방식: 빈 배열 생성
    const arr3 = new Array(5);    // (5) [empty × 5]

    // ⑤ 리터럴 방식: 가장 직관적인 병력 배치
    const arr2 = [1, 2, 3, 4, 5];


    /* =====================================================
       2. 다차원 배열 (Multi-dimensional Array)
    ===================================================== */
    // 2차원 배열 리터럴 (3x3 행렬)
    const twoDimArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
    // 배열은 차원과는 무관하게 1차원 공간에 연속적으로 데이터를 저장한다.

    // 요소 접근: 행(row)과 열(column)을 지정
    console.log('2행 3열 요소:', twoDimArray[1][2]); // 6
    twoDimArray[1][2] = 10; // 값 변경

    // [ Array(Row) -> map() -> Array(Col) -> 2D Array ]
    // 크기가 3*4인 배열을 선언하는 예
    const arr3by4 = [...new Array(3)].map((_, i) => new Array(4).fill(i));	//  [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]]


    /* =====================================================
       3. 배열과 문자열의 유사성
    ===================================================== */
    const str = '안녕하세요';
    // [ String -> Indexing -> Character ]
    document.write(`'안녕하세요'[2] : ${str[2]} <br>`); // '하'
    document.write(`'안녕하세요'[1*3] : ${str[1*3]} <br>`); // '세'
    document.write(`문자열 길이: ${str.length} <br><br>`);


    /* =====================================================
       4. 주요 배열 조작 전술 (Methods)
    ===================================================== */
    const fruits = ['사과', '수박', '딸기', '바나나'];

    fruits.push('망고');          // 끝에 추가
    fruits.concat(['포도', '키위']); // ['사과', '수박', '딸기', '바나나', '포도', '키위']
    fruits = [...fruits, ...['거봉', '샤인머스켓']]; // ['사과', '수박', '딸기', '바나나', '거봉', '샤인머스켓']
    fruit.unshift('레몬');        // 시작에 추가 : ['레몬', '사과', '수박', '딸기', '바나나']



    // [ Array -> .splice() -> Mutated Array ] : 특정 위치 추가/제거
    // splice(start)	전원 탈락	start 지점부터 배열 끝까지 모두 삭제
    // splice(start, n)	부분 삭제	start부터 n개만큼 삭제
    // splice(start, n, item)	교체	n개를 삭제하고 그 자리에 item 삽입
    // splice(start, 0, item)삽입아무것도 삭제하지 않고 start 위치에 item 추가
    fruits.splice(1, 0, "귤"); // 1번 인덱스에 '귤' 추가
    fruits.splice(1, 2);      // 1번 인덱스부터 2개 제거

    // 배열.indexOf(요소) : 배열에서 특정 요소의 인덱스 반환
    // [ Array -> .indexOf() -> Number(Index) ] : 위치 탐색
    const berryIndex = fruits.indexOf('딸기');

    // [ Array -> .pop() -> Removed Element ] : 끝 요소 추출후 반환 후 제거
    // [Array -> .shift() -> Removed Element ] : 시작 요소 추출후 반환 후 제거
    const lastFruit = fruits.pop();
    const firstFruit = fruits.shift(); // 시작 요소 추출후 반환 후 제거

    


    /* =====================================================
       5. 고차 함수 연계 (Advanced Strategy)
    ===================================================== */
    // [ Array -> .sort() -> Sorted Array ] : 정렬 (가나다/ABC순)
    const cities = ['서울', '대전', '대구', '부산', '제주도'];
    console.log(cities)	    // 원본 상태 : 
    cities.sort();  // 가나다 순으로 정렬
    //cities.sort((a, b) => a - b) // 오름차순 정렬
    

    // for문 : 정렬된 도시들을 하나씩 호출
    document.write('<h3>주요 도시 점검 목록</h3>');
    for (let i = 0; i < cities.length; i++) {
        
        document.write(`${i + 1}순위 도시: ${cities[i]} <br>`);

        if (cities[i].length === 3) {
          document.write(`3글자인 도시: ${cities[i]} <br>`);
        }
    }

    // (참고). 역순 정렬
    //fruits.reverse();
    //fruits.sort((a, b) => b - a) // 내림차순 정렬

    // [ Array -> .filter() -> New Array ] : 조건에 맞는 것만 추출
    const twoLetterCities = cities.filter(city => city.length === 2);
    
    // [ Array -> .includes() -> Boolean ] : 포함 여부 확인 연계
    const daeCities = cities.filter(city => city.includes('대'));

    // [ Array -> .join() -> String ] : 배열을 문자열로 병합
    const cityListString = daeCities.join(', ');

    const numbers = [1, 2, 3, 4, 5];
    const squares = numbers.map(num => num * num); // [1, 4, 9, 16, 25]
    const evens = numbers.filter(num => num % 2 === 0); // 짝수 필터링 [2, 4]

    const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 합계 15

    /* =====================================================
       6. 최신 문법 활용 (ES6+)
    ===================================================== */
    // [ Array -> Destructuring -> Variables ] : 구조 분해 할당
    const [first, second] = ['Hello', 'World'];

    // [ Array + Array -> Spread(...) -> Merged Array ] : 배열 병합
    const allNumbers = [...[2, 4, 6], ...[1, 3, 5]];    // [... arr1, ...arr2]

    // [ Array -> new Set() -> Spread(...) -> Unique Array ] : 중복 제거
    const names = ['Lee', 'Kim', 'Park', 'Lee', 'Kim'];
    const uniqueNames = [...new Set(names)];


    /* =====================================================
       [배열 핵심 메서드 요약]
       - push()     : 끝에 요소 추가
       - pop()      : 끝 요소 제거 및 반환
       - includes() : 포함 여부 확인 (T/F)
       - filter()   : 조건 만족 요소 추출 (새 배열)
       - map()      : 요소 변환/가공 (새 배열)
       - find()     : 조건 만족 첫 요소 반환
       - join()     : 배열을 문자열로 결합
       - split()    : 문자열을 배열로 분리
    ===================================================== */
  </script>
</head>
<body>
  <h3>지략의 결과는 콘솔(F12)과 화면의 출력을 통해 확인하십시오.</h3>
  <script>
    // 화면 출력 확인용
    document.write('<b>최종 도시 정렬:</b> ' + cities.join(' - ') + '<br>');
    document.write('<b>중복 제거된 성씨:</b> ' + uniqueNames.join(', '));
  </script>
</body>
</html>