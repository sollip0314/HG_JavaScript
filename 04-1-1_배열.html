<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    // 배열에 들어갈 수 있는 데이터 타입 : 숫자, 문자열, 불린, 함수, 객체, 배열
    const array = [123, 'String', true, function(){}, {}, [12, 34]]
    /* *********************** */
    /*   배열 선언 3가지 방법    */
    /* *********************** */
    // ① 리터럴을 이용하는 방법
    const arr1 = [1, 2, 3, 4, 5];
    
    //  ② 생성자를 이용하는 방법
    const arr2 = new Array(6);  // [undefined × 6]
    // map 메서드
    // map()으로 써줘도 되지만 인덱스를 파라미터로 사용하기 위해서 앞의 매개변수는 꼭 자리는 채워줘야 한다.
    // map(현재 요소, 인덱스, 전체 배열)
    // map 메서드의 index를 사용하기 위해 첫번째 자리는 꼭 서줘야 함.
    // _  :  현재 요소를 사용하지 않을 때 관례적으로 사용하는 이름
    const arr3 = [... new Array(6)].map((_, i) => i + 1); // [1, 2, 3, 4, 5, 6]
    
    // ③ Array.fill() 함수를 이용하는 방법
    const arr4 = new Array(6).fill(0); // [0, 0, 0, 0, 0, 0]

    // 배열과 차원
    // 배열은 2차원, 3차원 등 다차원 배열도 가능. 하지만 컴퓨터 메모리의 구조는 1차원이므로 2차원, 3차원 배열도 실제로는 1차원 공간에 저장한다.Array
    // 다시 말해 배열은 차원과는 무관하게 1차원 공간에 연속적으로 데이터를 저장한다.

    // 2차원 배열
    // 2차원 배열을 리터럴로 표현
    const twoDimArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

    // arr[1][2]  : 2차원 배열의 2번째 행(row)의 3번째 열(column) 요소에 접근
    console.log('twoDimArray[1][2] : ' + twoDimArray[1][2]);

    // twoDimArray[1][2]에 저장된 값을 10으로 변경
    twoDimArray[1][2] = 10;
    console.log('twoDimArray[1][2] 변경 후 : ' + twoDimArray[1][2]);

    // 크기가 3*4인 배열을 선언하는 예
    const arr3by4 = [...new Array(3)].map((_, i) => new Array(4).fill(i));  //  [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]]
    
    
    
    
    const str ='안녕하세요'
    document.write('안녕하세요[2] : ' + str[2])
    document.write('<br><br>')

    document.write('안녕하세요.length : ' + str.length)
    document.write('<br><br>')

    const numbers = [1, 2, 3, 4]
    document.write('numbers = [1, 2, 3, 4]<br>')
    document.write('numbers[1] : ' + numbers[1]);
    document.write('<br>')
    document.write('numbers[1*2] : ' + numbers[1*2]);
    document.write('<br><br>')
    

    const fruits = ['사과', '수박', '딸기', '바나나']
    document.write(fruits + '<br>');
    document.write('fruits[1] : ' + fruits[1]);
    document.write('<br>')
    document.write('fruits[fruits.length - 1] : ' + fruits[fruits.length - 1]);
    document.write('<br><br>')
    
    // push() : 배열에 요소 추가
    document.write(`fruits.push('망고')`)
    fruits.push('망고')
    document.write('<br>')
    document.write(fruits + '<br><br>');

    // 배열.splice(index, 0, 요소) : 배열의 특정 위치에 요소 추가(배열만 사용)
    document.write('fruits.splice(1, 0, "귤")<br>')
    fruits.splice(1, 0, "귤")
    document.write(fruits + '<br><br>');

    //배열.splice(index, 제거할 요소의 개수) : 배열의 특정 위치의 요소 제거(배열만 사용)
    document.write('fruits.splice(1, 2)  <br>')
    fruits.splice(1, 2)                     // 배열.splice(인덱스, 제거할 요소의 개수)
    document.write(fruits + '<br><br>');

    // 배열.indexOf(요소) : 배열에서 특정 요소의 인덱스 반환  indexOf : 배열, 문자열 사용
    
    document.write(fruits + '<br>');
    const 딸기index = fruits.indexOf('딸기')
    document.write(`fruits.indexOf('딸기') : `)
    document.write(딸기index + '<br><br>')
    

    // pop() : 배열의 마지막 요소 제거 후 반환
    document.write(fruits + '<br>');
    const last_fruit = fruits.pop()
    document.write('fruits.pop() 호출 : ' + last_fruit + '<br><br>')    
    document.write(fruits + '<br><br>');

    // 배열 정렬하기
    //1. 배열 선언
    const cities = ['서울', '대전', '대구', '부산', '제주도'];
    document.write('<b>[원본 상태]</b>: ' + cities + '<br><br>');

    // 2. sort() : 가나다 순으로 정렬
    cities.sort();
    document.write('<b>[정렬 후]</b>: ' + cities + '<br><br>');

    // 3. for문 : 정렬된 도시들을 하나씩 호출
    document.write('<h3>주요 도시 점검 목록</h3>');
    for (let i = 0; i < cities.length; i++) {
        
        document.write(`${i + 1}순위 도시: ${cities[i]} <br>`);

        if (cities[i].length === 3) {
          document.write(`3글자인 도시: ${cities[i]} <br>`);
        }
    }

    // (참고). 역순 정렬
    //fruits.reverse();
    //document.write('역순 정렬: ' + cities + '<br>');

    // 4. 배열.filter() : 배열에서 특정 조건에 맞는 요소들만 따로 모아 새로운 배열 셍성
    // 도시 이름(city)의 길이가 2인 것만 골라내어 newCities에 담습니다.
    const twoLetterCities = cities.filter(city => city.length === 2);
    document.write('<h3>필터링된 결과 (filter함수)</h3>');
    document.write(twoLetterCities.join(', '));

    // '대'라는 글자가 포함(includes)된 도시만 필터링합니다.
    const daeCities = cities.filter(city => city.includes('대'));

    document.write('<h3>이름에 "대"가 포함된 도시 목록</h3>');
    document.write(daeCities.join(', ')); // 쉼표 뒤에 한 칸을 띄웁니다. 
    // document.write(daeCities);


    // 배열 할당 by 구조 분해
    const arr = ['Hello', 'World', '!'];
    const [first, second] = arr;
    console.log(first, second); // Hello World

    // 배열 병합
    const evenNumbers = [2, 4, 6];
    const oddNumbers = [1, 3, 5];
    const allNumbers = [...evenNumbers, ...oddNumbers];
    console.log(allNumbers); // [2, 4, 6, 1, 3, 5]
    allNumbers.sort();
    console.log(allNumbers); // [1, 2, 3, 4, 5, 6]

    // 배열 내 중복 제거 ( ...스프레드 연산자 사용, Set 객체 활용)
    const names = ['Lee', 'Kim', 'Park', 'Lee', 'Kim'];
    const uniqueNames = [...new Set(names)];  // Set 객체 : 중복 요소 제거
    console.log(uniqueNames); // ['Lee', 'Kim', 'Park']

  </script>
</head>
<body>
  
</body>
</html>